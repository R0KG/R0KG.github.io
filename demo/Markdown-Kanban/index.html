<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Markdown Kanban</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      .card {
        cursor: grab;
      }
      .modal {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.4);
        display: none;
        align-items: center;
        justify-content: center;
      }
      .modal.open {
        display: flex;
      }
    </style>
  </head>
  <body class="bg-gray-50">
    <main class="max-w-7xl mx-auto p-6">
      <div class="flex items-center justify-between gap-3">
        <div>
          <h1 class="text-3xl font-semibold">Markdown Kanban</h1>
          <p class="text-gray-600">Simple three-column kanban. Import/export Markdown locally.</p>
        </div>
        <div class="flex items-center gap-2">
          <input id="search" type="search" placeholder="Search cards..." class="border rounded px-3 py-2 w-64" />
          <button id="export" class="px-3 py-2 rounded bg-blue-600 text-white">Export Markdown</button>
          <button id="copyMd" class="px-3 py-2 rounded bg-gray-100">Copy</button>
          <label class="px-3 py-2 rounded bg-gray-100 cursor-pointer"
            >Import MD<input id="file" type="file" accept=".md,text/markdown" class="hidden"
          /></label>
          <button id="reset" class="px-3 py-2 rounded bg-gray-100">Reset</button>
        </div>
      </div>

      <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mt-6">
        <div class="rounded border bg-white p-3">
          <div class="flex items-center justify-between mb-2">
            <h3 class="font-medium">Todo</h3>
            <span class="text-sm text-gray-500"><span id="count-todo">0</span></span>
          </div>
          <div id="todo" class="space-y-2 min-h-[120px]"></div>
          <div class="mt-3 space-y-2">
            <input id="new-title-todo" class="border rounded px-2 py-1 w-full" placeholder="Title" />
            <input id="new-desc-todo" class="border rounded px-2 py-1 w-full" placeholder="Description (optional)" />
            <button data-col="todo" class="add px-3 py-2 rounded bg-gray-100 w-full">Add</button>
          </div>
        </div>
        <div class="rounded border bg-white p-3">
          <div class="flex items-center justify-between mb-2">
            <h3 class="font-medium">Doing</h3>
            <span class="text-sm text-gray-500"><span id="count-doing">0</span></span>
          </div>
          <div id="doing" class="space-y-2 min-h-[120px]"></div>
          <div class="mt-3 space-y-2">
            <input id="new-title-doing" class="border rounded px-2 py-1 w-full" placeholder="Title" />
            <input id="new-desc-doing" class="border rounded px-2 py-1 w-full" placeholder="Description (optional)" />
            <button data-col="doing" class="add px-3 py-2 rounded bg-gray-100 w-full">Add</button>
          </div>
        </div>
        <div class="rounded border bg-white p-3">
          <div class="flex items-center justify-between mb-2">
            <h3 class="font-medium">Done</h3>
            <span class="text-sm text-gray-500"><span id="count-done">0</span></span>
          </div>
          <div id="done" class="space-y-2 min-h-[120px]"></div>
          <div class="mt-3 space-y-2">
            <input id="new-title-done" class="border rounded px-2 py-1 w-full" placeholder="Title" />
            <input id="new-desc-done" class="border rounded px-2 py-1 w-full" placeholder="Description (optional)" />
            <button data-col="done" class="add px-3 py-2 rounded bg-gray-100 w-full">Add</button>
          </div>
        </div>
      </div>

      <div id="modal" class="modal">
        <div class="bg-white rounded shadow p-4 w-[520px] max-w-[90vw]">
          <h3 class="text-lg font-medium mb-3">Edit card</h3>
          <div class="space-y-2">
            <input id="edit-title" class="border rounded px-2 py-1 w-full" />
            <textarea id="edit-desc" class="border rounded px-2 py-1 w-full h-28"></textarea>
          </div>
          <div class="flex gap-2 justify-end mt-3">
            <button id="cancelEdit" class="px-3 py-2 rounded bg-gray-100">Cancel</button>
            <button id="saveEdit" class="px-3 py-2 rounded bg-blue-600 text-white">Save</button>
          </div>
        </div>
      </div>
    </main>

    <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.6/Sortable.min.js"></script>
    <script>
      const storageKey = 'kanban'
      let state = JSON.parse(localStorage.getItem(storageKey) || '{"todo":[],"doing":[],"done":[]}')
      let searchTerm = ''
      let editing = { col: null, id: null }

      function uid() {
        return 'id_' + Math.random().toString(36).slice(2, 10) + Date.now().toString(36)
      }
      function ensureIds() {
        for (const col of ['todo', 'doing', 'done']) {
          state[col] = state[col].map((c) => ({ id: c.id || uid(), title: c.title || '', desc: c.desc || '' }))
        }
      }
      ensureIds()

      function save() {
        localStorage.setItem(storageKey, JSON.stringify(state))
      }

      function match(card) {
        if (!searchTerm) return true
        const q = searchTerm.toLowerCase()
        return (
          (card.title && card.title.toLowerCase().includes(q)) || (card.desc && card.desc.toLowerCase().includes(q))
        )
      }

      function createCardElement(col, card) {
        const wrapper = document.createElement('div')
        wrapper.className = 'card border rounded p-3 bg-white'
        wrapper.dataset.id = card.id
        const titleEl = document.createElement('div')
        titleEl.className = 'font-medium'
        titleEl.textContent = card.title || '(untitled)'
        const descEl = document.createElement('div')
        descEl.className = 'text-sm text-gray-600 mt-1 whitespace-pre-wrap'
        descEl.textContent = card.desc || ''
        const actions = document.createElement('div')
        actions.className = 'mt-2 flex gap-2'
        const btnLeft = document.createElement('button')
        btnLeft.className = 'px-2 py-1 rounded bg-gray-100'
        btnLeft.textContent = '◀'
        btnLeft.dataset.action = 'left'
        btnLeft.dataset.col = col
        btnLeft.dataset.id = card.id
        const btnRight = document.createElement('button')
        btnRight.className = 'px-2 py-1 rounded bg-gray-100'
        btnRight.textContent = '▶'
        btnRight.dataset.action = 'right'
        btnRight.dataset.col = col
        btnRight.dataset.id = card.id
        const btnEdit = document.createElement('button')
        btnEdit.className = 'px-2 py-1 rounded bg-gray-100'
        btnEdit.textContent = 'Edit'
        btnEdit.dataset.action = 'edit'
        btnEdit.dataset.col = col
        btnEdit.dataset.id = card.id
        const btnDel = document.createElement('button')
        btnDel.className = 'px-2 py-1 rounded bg-red-50 text-red-700'
        btnDel.textContent = 'Delete'
        btnDel.dataset.action = 'del'
        btnDel.dataset.col = col
        btnDel.dataset.id = card.id
        actions.appendChild(btnLeft)
        actions.appendChild(btnRight)
        actions.appendChild(btnEdit)
        actions.appendChild(btnDel)
        wrapper.appendChild(titleEl)
        wrapper.appendChild(descEl)
        wrapper.appendChild(actions)
        return wrapper
      }

      function render() {
        for (const col of ['todo', 'doing', 'done']) {
          const el = document.getElementById(col)
          el.innerHTML = ''
          const all = state[col]
          const visible = all.filter(match)
          for (const card of visible) el.appendChild(createCardElement(col, card))
          document.getElementById('count-' + col).textContent = `${visible.length}/${all.length}`
        }
        save()
      }

      function add(col, title, desc = '') {
        const t = (title || '').trim()
        const d = (desc || '').trim()
        if (!t) return
        state[col].push({ id: uid(), title: t, desc: d })
        render()
      }

      // Add handlers
      document.querySelectorAll('.add').forEach((btn) => {
        btn.addEventListener('click', () => {
          const col = btn.dataset.col
          const t = document.getElementById(`new-title-${col}`)
          const d = document.getElementById(`new-desc-${col}`)
          add(col, t.value, d.value)
          t.value = ''
          d.value = ''
        })
      })
      ;['todo', 'doing', 'done'].forEach((col) => {
        const t = document.getElementById(`new-title-${col}`)
        const d = document.getElementById(`new-desc-${col}`)
        const handler = (e) => {
          if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {
            e.preventDefault()
            add(col, t.value, d.value)
            t.value = ''
            d.value = ''
          }
        }
        t.addEventListener('keydown', handler)
        d.addEventListener('keydown', handler)
      })

      // Delegated actions
      document.body.addEventListener('click', (e) => {
        const t = e.target
        if (!(t instanceof HTMLElement)) return
        const action = t.dataset.action
        if (!action) return
        const col = t.dataset.col
        const id = t.dataset.id
        if (!col || !id) return
        const idx = state[col].findIndex((c) => c.id === id)
        if (idx === -1) return
        if (action === 'del') {
          state[col].splice(idx, 1)
          render()
          return
        }
        if (action === 'left' || action === 'right') {
          const order = ['todo', 'doing', 'done']
          let pos = order.indexOf(col)
          pos += action === 'left' ? -1 : 1
          pos = Math.max(0, Math.min(order.length - 1, pos))
          if (order[pos] !== col) {
            const [card] = state[col].splice(idx, 1)
            state[order[pos]].push(card)
            render()
          }
          return
        }
        if (action === 'edit') {
          editing = { col, id }
          const card = state[col][idx]
          document.getElementById('edit-title').value = card.title || ''
          document.getElementById('edit-desc').value = card.desc || ''
          document.getElementById('modal').classList.add('open')
        }
      })

      // Modal
      document
        .getElementById('cancelEdit')
        .addEventListener('click', () => document.getElementById('modal').classList.remove('open'))
      document.getElementById('saveEdit').addEventListener('click', () => {
        const { col, id } = editing
        if (!col || !id) return
        const idx = state[col].findIndex((c) => c.id === id)
        if (idx === -1) return
        state[col][idx].title = document.getElementById('edit-title').value.trim()
        state[col][idx].desc = document.getElementById('edit-desc').value.trim()
        document.getElementById('modal').classList.remove('open')
        render()
      })
      document.getElementById('modal').addEventListener('click', (e) => {
        if (e.target === e.currentTarget) e.currentTarget.classList.remove('open')
      })

      // Export / Copy
      function toMarkdown() {
        const section = (name, list) =>
          `## ${name}\n\n` + list.map((c) => `- **${c.title}**: ${c.desc}`).join('\n') + '\n'
        return (
          `---\nkanban: true\n---\n\n` +
          section('Todo', state.todo) +
          '\n' +
          section('Doing', state.doing) +
          '\n' +
          section('Done', state.done)
        )
      }
      document.getElementById('export').addEventListener('click', () => {
        const md = toMarkdown()
        const blob = new Blob([md], { type: 'text/markdown;charset=utf-8;' })
        const url = URL.createObjectURL(blob)
        const a = document.createElement('a')
        a.href = url
        a.download = 'kanban.md'
        a.click()
        URL.revokeObjectURL(url)
      })
      document.getElementById('copyMd').addEventListener('click', async () => {
        try {
          await navigator.clipboard.writeText(toMarkdown())
        } catch {}
      })

      // Import
      document.getElementById('file').addEventListener('change', async (e) => {
        const f = e.target.files && e.target.files[0]
        if (!f) return
        const text = await f.text()
        const blocks = text.split(/\n## /)
        const obj = { todo: [], doing: [], done: [] }
        for (const b of blocks) {
          const head = b.split('\n')[0].trim().toLowerCase()
          const items = b.split('\n').slice(1).filter(Boolean)
          const key = head.startsWith('todo')
            ? 'todo'
            : head.startsWith('doing')
              ? 'doing'
              : head.startsWith('done')
                ? 'done'
                : null
          if (!key) continue
          obj[key] = items.map((line) => {
            const m = line.match(/^[-*]\s+\*\*(.+?)\*\*:\s*(.*)$/)
            const title = m ? m[1] : line.replace(/^[-*]\s+/, '')
            const desc = m ? m[2] : ''
            return { id: uid(), title, desc }
          })
        }
        state = obj
        ensureIds()
        render()
        e.target.value = ''
      })

      // DnD
      ;['todo', 'doing', 'done'].forEach((colId) => {
        new Sortable(document.getElementById(colId), {
          group: 'kanban',
          animation: 150,
          onEnd: (evt) => {
            const from = evt.from.id
            const to = evt.to.id
            const id = evt.item && evt.item.dataset && evt.item.dataset.id
            if (!id) return
            const fromIdx = state[from].findIndex((c) => c.id === id)
            if (fromIdx === -1) return
            const [card] = state[from].splice(fromIdx, 1)
            state[to].splice(evt.newIndex, 0, card)
            render()
          },
        })
      })

      // Search
      const debouncedSearch = (() => {
        let t
        return (v) => {
          clearTimeout(t)
          t = setTimeout(() => {
            searchTerm = v || ''
            render()
          }, 200)
        }
      })()
      document.getElementById('search').addEventListener('input', (e) => debouncedSearch(e.target.value))

      // Reset
      document.getElementById('reset').addEventListener('click', () => {
        state = { todo: [], doing: [], done: [] }
        render()
      })

      // Shortcuts
      document.addEventListener('keydown', (e) => {
        const meta = e.ctrlKey || e.metaKey
        if (meta && (e.key === 'Backspace' || e.key === 'Delete')) {
          e.preventDefault()
          document.getElementById('reset').click()
        }
      })

      render()
    </script>
  </body>
</html>
